1. 자동 참조 카운팅(ARC)
   ARC는 iOS의 핵심 메모리 관리 기법입니다.
   - 컴파일러가 자동으로 객체의 참조 횟수를 추적하고 관리합니다.
   - 개발자가 직접 retain/release를 호출할 필요가 없어 메모리 관리의 복잡성이 크게 줄어듭니다.
   - 참조 횟수가 0이 되면 객체를 자동으로 해제합니다.
   - 순환 참조 문제를 방지하기 위해 weak와 unowned 참조를 제공합니다.

2. 값 타입과 참조 타입
   - 값 타입(구조체, 열거형 등)은 스택에 저장되어 빠르고 효율적으로 관리됩니다.
   - 참조 타입(클래스)은 힙에 저장되며 ARC로 관리됩니다.

3. 메모리 경고 시스템
   iOS는 앱에 메모리 부족 경고를 보내 불필요한 리소스를 해제할 기회를 제공합니다.

4. 지연 초기화(Lazy Initialization)
   필요한 시점에 객체를 생성하여 메모리 사용을 최적화합니다.

5. 메모리 분석 도구
   Xcode의 Instruments 등을 통해 메모리 사용량, 누수, 할당 등을 분석할 수 있습니다.

## 자동 참조 카운팅(ARC)는 어떻게 동작하나요?
- 객체가 생성될 때 ARC는 해당 객체에 대한 참조 카운트를 1로 설정합니다.
- 다른 객체나 변수가 해당 객체에 대한 강한 참조를 가질 때마다 참조 카운트가 증가합니다.
- 강한 참조가 제거되거나 범위를 벗어날 때 참조 카운트가 감소합니다.
- 참조 카운트가 0이 되면 ARC는 자동으로 해당 객체의 메모리를 해제합니다.

```
class Car {
    var name: String
    init(name: String) {
        self.name = name
        print("Car \(name) is initialized")
    }
    deinit {
        print("Car \(name) is being deinitialized")
    }
}

var car1: Car? = Car(name: "Tesla")  // 참조 카운트: 1
var car2 = car1  // 참조 카운트: 2
car1 = nil  // 참조 카운트: 1
car2 = nil  // 참조 카운트: 0, 객체 해제

```

## Garbage Collection과의 차이는 무엇인가요?
ARC(Automatic Reference Counting와 GC(Garbage Collection)은 둘 다 메모리 관리를 자동화하는 기술이지만 차이점이 존재합니다.

1. 작동 시점
   - ARC : 컴파일 시점에 참조 카운팅 코드를 삽입합니다.
   - GC : 런타임에 백그라운드 프로세스로 동작합니다.
2. 메모리 해제 시점
   - ARC : 참조 카운트가 0이 되는 즉시 객체를 해제합니다.
   - GC : 주기적으로 또는 메모리 부족 시 GC를 수행합니다.
3. 순환 참조 처리
   - ARC : 순환 참조를 자동으로 처리하지 못합니다. 개발자가 weak 또는 unowned 참조를 통해 수동으로 해결해야 합니다.
   - GC : 순환 참조를 포함한 전체 객체 그래프를 자동으로 처리할 수 있습니다.
4. 성능 예측
   - ARC : 객체 생성과 소멸 시 일정한 오버헤드가 발생하지만, 예상 가능한 성능을 제공합니다.
   - GC : GC 수행 시 일시적으로 애플리케이션이 멈출 수 있어 성능 예측이 어렵습니다.
5. 리소스 사용
   - ARC : 추가적인 백그라운드 프로세스가 필요없어 리소스 사용이 적습니다.
   - GC : 백그라운드에서 GC를 수행하므로 추가적인 CPU와 메모리 사용이 필요합니다.
6. 개발자 관여도
   - ARC : 개발자가 retain cycle을 방지하기 위해 메모리 관리에 주의를 기울여야 합니다.
   - GC : 개발자가 메모리 관리에 크게 신경 쓰지 않아도 됩니다.
